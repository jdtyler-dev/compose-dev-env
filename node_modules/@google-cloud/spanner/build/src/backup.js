"use strict";
/**
 * Copyright 2020 Google LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backup = void 0;
const promisify_1 = require("@google-cloud/promisify");
const common_1 = require("./common");
const _1 = require(".");
const google_gax_1 = require("google-gax");
const precise_date_1 = require("@google-cloud/precise-date");
/**
 * The {@link Backup} class represents a Cloud Spanner backup.
 *
 * Create a `Backup` object to interact with or create a Cloud Spanner backup.
 *
 * @class
 *
 * @example
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const backup = instance.backup('my-backup');
 */
class Backup {
    constructor(instance, name) {
        this.request = instance.request;
        this.instanceFormattedName_ = instance.formattedName_;
        this.formattedName_ = Backup.formatName_(instance.formattedName_, name);
        this.id = this.formattedName_.split('/').pop() || '';
        this.resourceHeader_ = {
            [common_1.CLOUD_RESOURCE_HEADER]: this.instanceFormattedName_,
        };
    }
    /**
     * @typedef {object} CreateBackupOptions
     * @property {string} databasePath The database path.
     * @property {string|number|google.protobuf.Timestamp|external:PreciseDate}
     *     expireTime The expire time of the backup.
     * @property {string|number|google.protobuf.Timestamp|external:PreciseDate}
     *     versionTime Take a backup of the state of the database at this time.
     * @property {google.spanner.admin.database.v1.ICreateBackupEncryptionConfig}
     *     encryptionConfig An encryption configuration describing the
     *     encryption type and key resources in Cloud KMS to be used to encrypt
     *     the backup.
     * @property {object} [gaxOptions] The request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @typedef {array} CreateBackupResponse
     * @property {Backup} 0 The new {@link Backup}.
     * @property {google.longrunning.Operation} 1 An {@link Operation} object that can be used to check
     *     the status of the request.
     * @property {object} 2 The full API response.
     */
    /**
     * @callback CreateBackupCallback
     * @param {?Error} err Request error, if any.
     * @param {Backup} backup The new {@link Backup}.
     * @param {google.longrunning.Operation} operation An {@link Operation} object that can be used to
     *     check the status of the request.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Create a backup.
     *
     * @method Backup#create
     * @param {CreateBackupOptions} options Parameters for creating a backup.
     * @param {CallOptions} [options.gaxOptions] The request configuration
     *     options, See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {CreateBackupCallback} [callback] Callback function.
     * @returns {Promise<CreateBackupResponse>} When resolved, the backup
     *     operation will have started, but will not have necessarily completed.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const oneDay = 1000 * 60 * 60 * 24;
     * const expireTime = Date.now() + oneDay;
     * const versionTime = Date.now() - oneDay;
     * const backup = instance.backup('my-backup');
     * const [, backupOperation] = await backup.create({
     *   databasePath: 'projects/my-project/instances/my-instance/databases/my-database',
     *   expireTime: expireTime,
     *   versionTime: versionTime,
     *   encryptionConfig: {
     *     encryptionType: 'CUSTOMER_MANAGED_ENCRYPTION',
     *     kmsKeyName: 'projects/my-project-id/my-region/keyRings/my-key-ring/cryptoKeys/my-key',
     *   },
     * });
     * // Await completion of the backup operation.
     * await backupOperation.promise();
     */
    create(options, callback) {
        const gaxOpts = options.gaxOptions;
        const reqOpts = {
            parent: this.instanceFormattedName_,
            backupId: this.id,
            backup: {
                database: options.databasePath,
                expireTime: _1.Spanner.timestamp(options.expireTime).toStruct(),
                name: this.formattedName_,
            },
        };
        if ('versionTime' in options) {
            reqOpts.backup.versionTime = _1.Spanner.timestamp(options.versionTime).toStruct();
        }
        if ('encryptionConfig' in options &&
            options.encryptionConfig) {
            reqOpts.encryptionConfig = options.encryptionConfig;
        }
        this.request({
            client: 'DatabaseAdminClient',
            method: 'createBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, operation, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            callback(null, this, operation, resp);
        });
    }
    /**
     * @typedef {array} GetMetadataResponse
     * @property {object} 0 The {@link Backup} metadata.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetMetadataCallback
     * @param {?Error} err Request error, if any.
     * @param {object} metadata The {@link Backup} metadata.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Retrieves backup's metadata.
     *
     * @see {@link #getState}
     * @see {@link #getExpireTime}
     *
     * @method Backup#getMetadata
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetMetadataCallback} [callback] Callback function.
     * @returns {Promise<GetMetadataResponse>}
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * const [backupInfo] = await backup.getMetadata();
     * console.log(`${backupInfo.name}: size=${backupInfo.sizeBytes}`);
     */
    getMetadata(gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            name: this.formattedName_,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'getBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, response) => {
            if (response) {
                this.metadata = response;
            }
            callback(err, response);
        });
    }
    /**
     * Retrieves the state of the backup.
     *
     * The backup state indicates if the backup has completed.
     *
     * @see {@link #getMetadata}
     *
     * @method Backup#getState
     * @param {GetStateCallback} [callback] Callback function.
     * @returns {Promise<EnumKey<typeof, databaseAdmin.spanner.admin.database.v1.Backup.State> | undefined>}
     *     When resolved, contains the current state of the backup if it exists.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * const state = await backup.getState();
     * const backupCompleted = (state === 'READY');
     */
    async getState() {
        const [backupInfo] = await this.getMetadata();
        return backupInfo.state;
    }
    /**
     * Retrieves the expiry time of the backup.
     *
     * @see {@link #updateExpireTime}
     * @see {@link #getMetadata}
     *
     * @method Backup#getExpireTime
     * @returns {Promise<external:PreciseDate>} When resolved, contains the
     *     current expire time of the backup if it exists.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * const expireTime = await backup.getExpireTime();
     * console.log(`Backup expires on ${expireTime.toISOString()}`);
     */
    async getExpireTime() {
        const [backupInfo] = await this.getMetadata();
        return new precise_date_1.PreciseDate(backupInfo.expireTime);
    }
    /**
     * Checks whether the backup exists.
     *
     * @see {@link #getMetadata}
     *
     * @method Backup#exists
     * @returns {Promise<boolean>} When resolved, contains true if the backup
     *     exists and false if it does not exist.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * const alreadyExists = await backup.exists();
     * console.log(`Does backup exist? ${alreadyExists}`);
     */
    async exists() {
        try {
            // Attempt to read metadata to determine whether backup exists
            await this.getMetadata();
            // Found therefore it exists
            return true;
        }
        catch (err) {
            if (err.code === google_gax_1.grpc.status.NOT_FOUND) {
                return false;
            }
            // Some other error occurred, rethrow
            throw err;
        }
    }
    /**
     * @callback UpdateExpireTimeCallback
     * @param {?Error} err Request error, if any.
     * @param {google.spanner.admin.database.v1.IBackup} backup The updated
     *     backup.
     */
    /**
     * Sets the expiry time of a backup.
     *
     * @see {@link #getExpireTime}
     *
     * @method Backup#updateExpireTime
     * @param {string|number|google.protobuf.Timestamp|external:PreciseDate}
     *     expireTime The expiry time to update with.
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {UpdateExpireTimeCallback} [callback] Callback function.
     * @returns {Promise<google.spanner.admin.database.v1.IBackup>} When resolved,
     *     the backup's expire time will have been updated.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * const oneDay = 1000 * 60 * 60 * 24;
     * const newExpireTime = Spanner.timestamp(Date.now() + oneDay);
     * await backup.updateExpireTime(newExpireTime);
     */
    updateExpireTime(expireTime, gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            backup: {
                name: this.formattedName_,
                expireTime: _1.Spanner.timestamp(expireTime).toStruct(),
            },
            updateMask: {
                paths: ['expire_time'],
            },
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'updateBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, response) => {
            callback(err, response);
        });
    }
    /**
     * Deletes a backup.
     *
     * @method Backup#delete
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {DeleteBackupCallback} [callback] Callback function.
     * @returns {Promise<void>} When resolved, the backup will have been deleted.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const backup = instance.backup('my-backup');
     * await backup.delete();
     */
    delete(gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            name: this.formattedName_,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'deleteBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, err => {
            callback(err);
        });
    }
    /**
     * Format the backup name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * Backup.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-backup'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/backups/my-backup'
     */
    static formatName_(instanceName, name) {
        if (name.indexOf('/') > -1) {
            return name;
        }
        const backupName = name.split('/').pop();
        return instanceName + '/backups/' + backupName;
    }
}
exports.Backup = Backup;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
promisify_1.promisifyAll(Backup, {
    exclude: ['getState', 'getExpireTime', 'exists'],
});
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
promisify_1.callbackifyAll(Backup, {
    exclude: ['create', 'getMetadata', 'updateExpireTime', 'delete'],
});
//# sourceMappingURL=backup.js.map
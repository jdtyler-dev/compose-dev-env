/// <reference types="node" />
import * as gax from 'google-gax';
import { Callback, CallOptions, Descriptors, ClientOptions, PaginationCallback } from 'google-gax';
import { Transform } from 'stream';
import * as protos from '../../protos/protos';
/**
 *  Cloud Spanner API
 *
 *  The Cloud Spanner API can be used to manage sessions and execute
 *  transactions on data stored in Cloud Spanner databases.
 * @class
 * @memberof v1
 */
export declare class SpannerClient {
    private _terminated;
    private _opts;
    private _gaxModule;
    private _gaxGrpc;
    private _protos;
    private _defaults;
    auth: gax.GoogleAuth;
    descriptors: Descriptors;
    innerApiCalls: {
        [name: string]: Function;
    };
    pathTemplates: {
        [name: string]: gax.PathTemplate;
    };
    spannerStub?: Promise<{
        [name: string]: Function;
    }>;
    /**
     * Construct an instance of SpannerClient.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP fallback mode.
     *     In fallback mode, a special browser-compatible transport implementation is used
     *     instead of gRPC transport. In browser context (if the `window` object is defined)
     *     the fallback mode is enabled automatically; set `options.fallback` to `false`
     *     if you need to override this behavior.
     */
    constructor(opts?: ClientOptions);
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */
    initialize(): Promise<{
        [name: string]: Function;
    }>;
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */
    static get servicePath(): string;
    /**
     * The DNS address for this API service - same as servicePath(),
     * exists for compatibility reasons.
     * @returns {string} The DNS address for this service.
     */
    static get apiEndpoint(): string;
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */
    static get port(): number;
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */
    static get scopes(): string[];
    getProjectId(): Promise<string>;
    getProjectId(callback: Callback<string, undefined, undefined>): void;
    createSession(request?: protos.google.spanner.v1.ICreateSessionRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.ISession, protos.google.spanner.v1.ICreateSessionRequest | undefined, {} | undefined]>;
    createSession(request: protos.google.spanner.v1.ICreateSessionRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.ISession, protos.google.spanner.v1.ICreateSessionRequest | null | undefined, {} | null | undefined>): void;
    createSession(request: protos.google.spanner.v1.ICreateSessionRequest, callback: Callback<protos.google.spanner.v1.ISession, protos.google.spanner.v1.ICreateSessionRequest | null | undefined, {} | null | undefined>): void;
    batchCreateSessions(request?: protos.google.spanner.v1.IBatchCreateSessionsRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IBatchCreateSessionsResponse, protos.google.spanner.v1.IBatchCreateSessionsRequest | undefined, {} | undefined]>;
    batchCreateSessions(request: protos.google.spanner.v1.IBatchCreateSessionsRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IBatchCreateSessionsResponse, protos.google.spanner.v1.IBatchCreateSessionsRequest | null | undefined, {} | null | undefined>): void;
    batchCreateSessions(request: protos.google.spanner.v1.IBatchCreateSessionsRequest, callback: Callback<protos.google.spanner.v1.IBatchCreateSessionsResponse, protos.google.spanner.v1.IBatchCreateSessionsRequest | null | undefined, {} | null | undefined>): void;
    getSession(request?: protos.google.spanner.v1.IGetSessionRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.ISession, protos.google.spanner.v1.IGetSessionRequest | undefined, {} | undefined]>;
    getSession(request: protos.google.spanner.v1.IGetSessionRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.ISession, protos.google.spanner.v1.IGetSessionRequest | null | undefined, {} | null | undefined>): void;
    getSession(request: protos.google.spanner.v1.IGetSessionRequest, callback: Callback<protos.google.spanner.v1.ISession, protos.google.spanner.v1.IGetSessionRequest | null | undefined, {} | null | undefined>): void;
    deleteSession(request?: protos.google.spanner.v1.IDeleteSessionRequest, options?: CallOptions): Promise<[protos.google.protobuf.IEmpty, protos.google.spanner.v1.IDeleteSessionRequest | undefined, {} | undefined]>;
    deleteSession(request: protos.google.spanner.v1.IDeleteSessionRequest, options: CallOptions, callback: Callback<protos.google.protobuf.IEmpty, protos.google.spanner.v1.IDeleteSessionRequest | null | undefined, {} | null | undefined>): void;
    deleteSession(request: protos.google.spanner.v1.IDeleteSessionRequest, callback: Callback<protos.google.protobuf.IEmpty, protos.google.spanner.v1.IDeleteSessionRequest | null | undefined, {} | null | undefined>): void;
    executeSql(request?: protos.google.spanner.v1.IExecuteSqlRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IExecuteSqlRequest | undefined, {} | undefined]>;
    executeSql(request: protos.google.spanner.v1.IExecuteSqlRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IExecuteSqlRequest | null | undefined, {} | null | undefined>): void;
    executeSql(request: protos.google.spanner.v1.IExecuteSqlRequest, callback: Callback<protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IExecuteSqlRequest | null | undefined, {} | null | undefined>): void;
    executeBatchDml(request?: protos.google.spanner.v1.IExecuteBatchDmlRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IExecuteBatchDmlResponse, protos.google.spanner.v1.IExecuteBatchDmlRequest | undefined, {} | undefined]>;
    executeBatchDml(request: protos.google.spanner.v1.IExecuteBatchDmlRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IExecuteBatchDmlResponse, protos.google.spanner.v1.IExecuteBatchDmlRequest | null | undefined, {} | null | undefined>): void;
    executeBatchDml(request: protos.google.spanner.v1.IExecuteBatchDmlRequest, callback: Callback<protos.google.spanner.v1.IExecuteBatchDmlResponse, protos.google.spanner.v1.IExecuteBatchDmlRequest | null | undefined, {} | null | undefined>): void;
    read(request?: protos.google.spanner.v1.IReadRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IReadRequest | undefined, {} | undefined]>;
    read(request: protos.google.spanner.v1.IReadRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IReadRequest | null | undefined, {} | null | undefined>): void;
    read(request: protos.google.spanner.v1.IReadRequest, callback: Callback<protos.google.spanner.v1.IResultSet, protos.google.spanner.v1.IReadRequest | null | undefined, {} | null | undefined>): void;
    beginTransaction(request?: protos.google.spanner.v1.IBeginTransactionRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.ITransaction, protos.google.spanner.v1.IBeginTransactionRequest | undefined, {} | undefined]>;
    beginTransaction(request: protos.google.spanner.v1.IBeginTransactionRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.ITransaction, protos.google.spanner.v1.IBeginTransactionRequest | null | undefined, {} | null | undefined>): void;
    beginTransaction(request: protos.google.spanner.v1.IBeginTransactionRequest, callback: Callback<protos.google.spanner.v1.ITransaction, protos.google.spanner.v1.IBeginTransactionRequest | null | undefined, {} | null | undefined>): void;
    commit(request?: protos.google.spanner.v1.ICommitRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.ICommitResponse, protos.google.spanner.v1.ICommitRequest | undefined, {} | undefined]>;
    commit(request: protos.google.spanner.v1.ICommitRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.ICommitResponse, protos.google.spanner.v1.ICommitRequest | null | undefined, {} | null | undefined>): void;
    commit(request: protos.google.spanner.v1.ICommitRequest, callback: Callback<protos.google.spanner.v1.ICommitResponse, protos.google.spanner.v1.ICommitRequest | null | undefined, {} | null | undefined>): void;
    rollback(request?: protos.google.spanner.v1.IRollbackRequest, options?: CallOptions): Promise<[protos.google.protobuf.IEmpty, protos.google.spanner.v1.IRollbackRequest | undefined, {} | undefined]>;
    rollback(request: protos.google.spanner.v1.IRollbackRequest, options: CallOptions, callback: Callback<protos.google.protobuf.IEmpty, protos.google.spanner.v1.IRollbackRequest | null | undefined, {} | null | undefined>): void;
    rollback(request: protos.google.spanner.v1.IRollbackRequest, callback: Callback<protos.google.protobuf.IEmpty, protos.google.spanner.v1.IRollbackRequest | null | undefined, {} | null | undefined>): void;
    partitionQuery(request?: protos.google.spanner.v1.IPartitionQueryRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionQueryRequest | undefined, {} | undefined]>;
    partitionQuery(request: protos.google.spanner.v1.IPartitionQueryRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionQueryRequest | null | undefined, {} | null | undefined>): void;
    partitionQuery(request: protos.google.spanner.v1.IPartitionQueryRequest, callback: Callback<protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionQueryRequest | null | undefined, {} | null | undefined>): void;
    partitionRead(request?: protos.google.spanner.v1.IPartitionReadRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionReadRequest | undefined, {} | undefined]>;
    partitionRead(request: protos.google.spanner.v1.IPartitionReadRequest, options: CallOptions, callback: Callback<protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionReadRequest | null | undefined, {} | null | undefined>): void;
    partitionRead(request: protos.google.spanner.v1.IPartitionReadRequest, callback: Callback<protos.google.spanner.v1.IPartitionResponse, protos.google.spanner.v1.IPartitionReadRequest | null | undefined, {} | null | undefined>): void;
    /**
     * Like {@link google.spanner.v1.Spanner.ExecuteSql|ExecuteSql}, except returns the result
     * set as a stream. Unlike {@link google.spanner.v1.Spanner.ExecuteSql|ExecuteSql}, there
     * is no limit on the size of the returned result set. However, no
     * individual row in the result set can exceed 100 MiB, and no
     * column value can exceed 10 MiB.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.session
     *   Required. The session in which the SQL query should be performed.
     * @param {google.spanner.v1.TransactionSelector} request.transaction
     *   The transaction to use.
     *
     *   For queries, if none is provided, the default is a temporary read-only
     *   transaction with strong concurrency.
     *
     *   Standard DML statements require a read-write transaction. To protect
     *   against replays, single-use transactions are not supported.  The caller
     *   must either supply an existing transaction ID or begin a new transaction.
     *
     *   Partitioned DML requires an existing Partitioned DML transaction ID.
     * @param {string} request.sql
     *   Required. The SQL string.
     * @param {google.protobuf.Struct} request.params
     *   Parameter names and values that bind to placeholders in the SQL string.
     *
     *   A parameter placeholder consists of the `@` character followed by the
     *   parameter name (for example, `@firstName`). Parameter names must conform
     *   to the naming requirements of identifiers as specified at
     *   https://cloud.google.com/spanner/docs/lexical#identifiers.
     *
     *   Parameters can appear anywhere that a literal value is expected.  The same
     *   parameter name can be used more than once, for example:
     *
     *   `"WHERE id > @msg_id AND id < @msg_id + 100"`
     *
     *   It is an error to execute a SQL statement with unbound parameters.
     * @param {number[]} request.paramTypes
     *   It is not always possible for Cloud Spanner to infer the right SQL type
     *   from a JSON value.  For example, values of type `BYTES` and values
     *   of type `STRING` both appear in {@link google.spanner.v1.ExecuteSqlRequest.params|params} as JSON strings.
     *
     *   In these cases, `param_types` can be used to specify the exact
     *   SQL type for some or all of the SQL statement parameters. See the
     *   definition of {@link google.spanner.v1.Type|Type} for more information
     *   about SQL types.
     * @param {Buffer} request.resumeToken
     *   If this request is resuming a previously interrupted SQL statement
     *   execution, `resume_token` should be copied from the last
     *   {@link google.spanner.v1.PartialResultSet|PartialResultSet} yielded before the interruption. Doing this
     *   enables the new SQL statement execution to resume where the last one left
     *   off. The rest of the request parameters must exactly match the
     *   request that yielded this token.
     * @param {google.spanner.v1.ExecuteSqlRequest.QueryMode} request.queryMode
     *   Used to control the amount of debugging information returned in
     *   {@link google.spanner.v1.ResultSetStats|ResultSetStats}. If {@link google.spanner.v1.ExecuteSqlRequest.partition_token|partition_token} is set, {@link google.spanner.v1.ExecuteSqlRequest.query_mode|query_mode} can only
     *   be set to {@link google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL|QueryMode.NORMAL}.
     * @param {Buffer} request.partitionToken
     *   If present, results will be restricted to the specified partition
     *   previously created using PartitionQuery().  There must be an exact
     *   match for the values of fields common to this message and the
     *   PartitionQueryRequest message used to create this partition_token.
     * @param {number} request.seqno
     *   A per-transaction sequence number used to identify this request. This field
     *   makes each request idempotent such that if the request is received multiple
     *   times, at most one will succeed.
     *
     *   The sequence number must be monotonically increasing within the
     *   transaction. If a request arrives for the first time with an out-of-order
     *   sequence number, the transaction may be aborted. Replays of previously
     *   handled requests will yield the same response as the first execution.
     *
     *   Required for DML statements. Ignored for queries.
     * @param {google.spanner.v1.ExecuteSqlRequest.QueryOptions} request.queryOptions
     *   Query optimizer configuration to use for the given query.
     * @param {google.spanner.v1.RequestOptions} request.requestOptions
     *   Common options for this request.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits [PartialResultSet]{@link google.spanner.v1.PartialResultSet} on 'data' event.
     *   Please see the
     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming)
     *   for more details and examples.
     * @example
     * const stream = client.executeStreamingSql(request);
     * stream.on('data', (response) => { ... });
     * stream.on('end', () => { ... });
     */
    executeStreamingSql(request?: protos.google.spanner.v1.IExecuteSqlRequest, options?: CallOptions): gax.CancellableStream;
    /**
     * Like {@link google.spanner.v1.Spanner.Read|Read}, except returns the result set as a
     * stream. Unlike {@link google.spanner.v1.Spanner.Read|Read}, there is no limit on the
     * size of the returned result set. However, no individual row in
     * the result set can exceed 100 MiB, and no column value can exceed
     * 10 MiB.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.session
     *   Required. The session in which the read should be performed.
     * @param {google.spanner.v1.TransactionSelector} request.transaction
     *   The transaction to use. If none is provided, the default is a
     *   temporary read-only transaction with strong concurrency.
     * @param {string} request.table
     *   Required. The name of the table in the database to be read.
     * @param {string} request.index
     *   If non-empty, the name of an index on {@link google.spanner.v1.ReadRequest.table|table}. This index is
     *   used instead of the table primary key when interpreting {@link google.spanner.v1.ReadRequest.key_set|key_set}
     *   and sorting result rows. See {@link google.spanner.v1.ReadRequest.key_set|key_set} for further information.
     * @param {string[]} request.columns
     *   Required. The columns of {@link google.spanner.v1.ReadRequest.table|table} to be returned for each row matching
     *   this request.
     * @param {google.spanner.v1.KeySet} request.keySet
     *   Required. `key_set` identifies the rows to be yielded. `key_set` names the
     *   primary keys of the rows in {@link google.spanner.v1.ReadRequest.table|table} to be yielded, unless {@link google.spanner.v1.ReadRequest.index|index}
     *   is present. If {@link google.spanner.v1.ReadRequest.index|index} is present, then {@link google.spanner.v1.ReadRequest.key_set|key_set} instead names
     *   index keys in {@link google.spanner.v1.ReadRequest.index|index}.
     *
     *   If the {@link google.spanner.v1.ReadRequest.partition_token|partition_token} field is empty, rows are yielded
     *   in table primary key order (if {@link google.spanner.v1.ReadRequest.index|index} is empty) or index key order
     *   (if {@link google.spanner.v1.ReadRequest.index|index} is non-empty).  If the {@link google.spanner.v1.ReadRequest.partition_token|partition_token} field is not
     *   empty, rows will be yielded in an unspecified order.
     *
     *   It is not an error for the `key_set` to name rows that do not
     *   exist in the database. Read yields nothing for nonexistent rows.
     * @param {number} request.limit
     *   If greater than zero, only the first `limit` rows are yielded. If `limit`
     *   is zero, the default is no limit. A limit cannot be specified if
     *   `partition_token` is set.
     * @param {Buffer} request.resumeToken
     *   If this request is resuming a previously interrupted read,
     *   `resume_token` should be copied from the last
     *   {@link google.spanner.v1.PartialResultSet|PartialResultSet} yielded before the interruption. Doing this
     *   enables the new read to resume where the last read left off. The
     *   rest of the request parameters must exactly match the request
     *   that yielded this token.
     * @param {Buffer} request.partitionToken
     *   If present, results will be restricted to the specified partition
     *   previously created using PartitionRead().    There must be an exact
     *   match for the values of fields common to this message and the
     *   PartitionReadRequest message used to create this partition_token.
     * @param {google.spanner.v1.RequestOptions} request.requestOptions
     *   Common options for this request.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits [PartialResultSet]{@link google.spanner.v1.PartialResultSet} on 'data' event.
     *   Please see the
     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming)
     *   for more details and examples.
     * @example
     * const stream = client.streamingRead(request);
     * stream.on('data', (response) => { ... });
     * stream.on('end', () => { ... });
     */
    streamingRead(request?: protos.google.spanner.v1.IReadRequest, options?: CallOptions): gax.CancellableStream;
    listSessions(request?: protos.google.spanner.v1.IListSessionsRequest, options?: CallOptions): Promise<[protos.google.spanner.v1.ISession[], protos.google.spanner.v1.IListSessionsRequest | null, protos.google.spanner.v1.IListSessionsResponse]>;
    listSessions(request: protos.google.spanner.v1.IListSessionsRequest, options: CallOptions, callback: PaginationCallback<protos.google.spanner.v1.IListSessionsRequest, protos.google.spanner.v1.IListSessionsResponse | null | undefined, protos.google.spanner.v1.ISession>): void;
    listSessions(request: protos.google.spanner.v1.IListSessionsRequest, callback: PaginationCallback<protos.google.spanner.v1.IListSessionsRequest, protos.google.spanner.v1.IListSessionsResponse | null | undefined, protos.google.spanner.v1.ISession>): void;
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.database
     *   Required. The database in which to list sessions.
     * @param {number} request.pageSize
     *   Number of sessions to be returned in the response. If 0 or less, defaults
     *   to the server's maximum allowed page size.
     * @param {string} request.pageToken
     *   If non-empty, `page_token` should contain a
     *   {@link google.spanner.v1.ListSessionsResponse.next_page_token|next_page_token} from a previous
     *   {@link google.spanner.v1.ListSessionsResponse|ListSessionsResponse}.
     * @param {string} request.filter
     *   An expression for filtering the results of the request. Filter rules are
     *   case insensitive. The fields eligible for filtering are:
     *
     *     * `labels.key` where key is the name of a label
     *
     *   Some examples of using filters are:
     *
     *     * `labels.env:*` --> The session has the label "env".
     *     * `labels.env:dev` --> The session has the label "env" and the value of
     *                          the label contains the string "dev".
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing [Session]{@link google.spanner.v1.Session} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSessionsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the
     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
     *   for more details and examples.
     */
    listSessionsStream(request?: protos.google.spanner.v1.IListSessionsRequest, options?: CallOptions): Transform;
    /**
     * Equivalent to `listSessions`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.database
     *   Required. The database in which to list sessions.
     * @param {number} request.pageSize
     *   Number of sessions to be returned in the response. If 0 or less, defaults
     *   to the server's maximum allowed page size.
     * @param {string} request.pageToken
     *   If non-empty, `page_token` should contain a
     *   {@link google.spanner.v1.ListSessionsResponse.next_page_token|next_page_token} from a previous
     *   {@link google.spanner.v1.ListSessionsResponse|ListSessionsResponse}.
     * @param {string} request.filter
     *   An expression for filtering the results of the request. Filter rules are
     *   case insensitive. The fields eligible for filtering are:
     *
     *     * `labels.key` where key is the name of a label
     *
     *   Some examples of using filters are:
     *
     *     * `labels.env:*` --> The session has the label "env".
     *     * `labels.env:dev` --> The session has the label "env" and the value of
     *                          the label contains the string "dev".
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
     *   When you iterate the returned iterable, each element will be an object representing
     *   [Session]{@link google.spanner.v1.Session}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the
     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
     *   for more details and examples.
     * @example
     * const iterable = client.listSessionsAsync(request);
     * for await (const response of iterable) {
     *   // process response
     * }
     */
    listSessionsAsync(request?: protos.google.spanner.v1.IListSessionsRequest, options?: CallOptions): AsyncIterable<protos.google.spanner.v1.ISession>;
    /**
     * Return a fully-qualified database resource name string.
     *
     * @param {string} project
     * @param {string} instance
     * @param {string} database
     * @returns {string} Resource name string.
     */
    databasePath(project: string, instance: string, database: string): string;
    /**
     * Parse the project from Database resource.
     *
     * @param {string} databaseName
     *   A fully-qualified path representing Database resource.
     * @returns {string} A string representing the project.
     */
    matchProjectFromDatabaseName(databaseName: string): string | number;
    /**
     * Parse the instance from Database resource.
     *
     * @param {string} databaseName
     *   A fully-qualified path representing Database resource.
     * @returns {string} A string representing the instance.
     */
    matchInstanceFromDatabaseName(databaseName: string): string | number;
    /**
     * Parse the database from Database resource.
     *
     * @param {string} databaseName
     *   A fully-qualified path representing Database resource.
     * @returns {string} A string representing the database.
     */
    matchDatabaseFromDatabaseName(databaseName: string): string | number;
    /**
     * Return a fully-qualified session resource name string.
     *
     * @param {string} project
     * @param {string} instance
     * @param {string} database
     * @param {string} session
     * @returns {string} Resource name string.
     */
    sessionPath(project: string, instance: string, database: string, session: string): string;
    /**
     * Parse the project from Session resource.
     *
     * @param {string} sessionName
     *   A fully-qualified path representing Session resource.
     * @returns {string} A string representing the project.
     */
    matchProjectFromSessionName(sessionName: string): string | number;
    /**
     * Parse the instance from Session resource.
     *
     * @param {string} sessionName
     *   A fully-qualified path representing Session resource.
     * @returns {string} A string representing the instance.
     */
    matchInstanceFromSessionName(sessionName: string): string | number;
    /**
     * Parse the database from Session resource.
     *
     * @param {string} sessionName
     *   A fully-qualified path representing Session resource.
     * @returns {string} A string representing the database.
     */
    matchDatabaseFromSessionName(sessionName: string): string | number;
    /**
     * Parse the session from Session resource.
     *
     * @param {string} sessionName
     *   A fully-qualified path representing Session resource.
     * @returns {string} A string representing the session.
     */
    matchSessionFromSessionName(sessionName: string): string | number;
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */
    close(): Promise<void>;
}

/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { EventEmitter } from 'events';
import PQueue from 'p-queue';
import { Database } from './database';
import { Session, types } from './session';
import { Transaction } from './transaction';
import { NormalCallback } from './common';
import { grpc } from 'google-gax';
import trace = require('stack-trace');
/**
 * @callback SessionPoolCloseCallback
 * @param {?Error} error Closing error, if any.
 */
export interface SessionPoolCloseCallback {
    (error?: SessionLeakError): void;
}
/**
 * @callback GetReadSessionCallback
 * @param {?Error} error Request error, if any.
 * @param {Session} session The read-only session.
 */
export declare type GetReadSessionCallback = NormalCallback<Session>;
/**
 * @callback GetWriteSessionCallback
 * @param {?Error} error Request error, if any.
 * @param {Session} session The read-write session.
 * @param {Transaction} transaction The transaction object.
 */
export interface GetWriteSessionCallback {
    (err: Error | null, session?: Session | null, transaction?: Transaction | null): void;
}
/**
 * Interface for implementing custom session pooling logic, it should extend the
 * {@link https://nodejs.org/api/events.html|EventEmitter} class and emit any
 * asynchronous errors via an error event.
 *
 * @interface SessionPoolInterface
 * @extends external:{@link https://nodejs.org/api/events.html|EventEmitter}
 */
/**
 * @constructs SessionPoolInterface
 * @param {Database} database The database to create a pool for.
 */
export interface SessionPoolInterface extends EventEmitter {
    /**
     * Will be called via {@link Database#close}. Indicates that the pool should
     * perform any necessary teardown actions to its resources.
     *
     * @name SessionPoolInterface#close
     * @param {SessionPoolCloseCallback} callback The callback function.
     */
    close(callback: SessionPoolCloseCallback): void;
    /**
     * Will be called by the Database object, should be used to start creating
     * sessions/etc.
     *
     * @name SessionPoolInterface#open
     */
    open(): void;
    /**
     * When called returns a read-only session.
     *
     * @name SessionPoolInterface#getReadSession
     * @param {GetReadSessionCallback} callback The callback function.
     */
    getReadSession(callback: GetReadSessionCallback): void;
    /**
     * When called returns a read-write session with prepared transaction.
     *
     * @name SessionPoolInterface#getWriteSession
     * @param {GetWriteSessionCallback} callback The callback function.
     */
    getWriteSession(callback: GetWriteSessionCallback): void;
    /**
     * To be called when releasing a session back into the pool.
     *
     * @name SessionPoolInterface#release
     * @param {Session} session The session to be released.
     */
    release(session: Session): void;
}
/**
 * Session pool configuration options.
 *
 * @typedef {object} SessionPoolOptions
 * @property {number} [acquireTimeout=Infinity] Time in milliseconds before
 *     giving up trying to acquire a session. If the specified value is
 *     `Infinity`, a timeout will not occur.
 * @property {number} [concurrency=10] How many concurrent requests the pool is
 *     allowed to make.
 * @property {boolean} [fail=false] If set to true, an error will be thrown when
 *     there are no available sessions for a request.
 * @property {number} [idlesAfter=10] How long until a resource becomes idle, in
 *     minutes.
 * @property {number} [keepAlive=50] How often to ping idle sessions, in
 *     minutes. Must be less than 1 hour.
 * @property {Object<string, string>} [labels] Labels to apply to any session
 *     created by the pool.
 * @property {number} [max=100] Maximum number of resources to create at any
 *     given time.
 * @property {number} [maxIdle=1] Maximum number of idle resources to keep in
 *     the pool at any given time.
 * @property {number} [min=0] Minimum number of resources to keep in the pool at
 *     any given time.
 * @property {number} [writes=0.0] Percentage of sessions to be pre-allocated as
 *     write sessions represented as a float.
 * @property {number} [incStep=25] The number of new sessions to create when at
 *     least one more session is needed.
 */
export interface SessionPoolOptions {
    acquireTimeout?: number;
    concurrency?: number;
    fail?: boolean;
    idlesAfter?: number;
    keepAlive?: number;
    labels?: {
        [label: string]: string;
    };
    max?: number;
    maxIdle?: number;
    min?: number;
    writes?: number;
    incStep?: number;
}
/**
 * Error to be thrown when attempting to release unknown resources.
 *
 * @private
 */
export declare class ReleaseError extends Error {
    resource: unknown;
    constructor(resource: unknown);
}
/**
 * Error to be thrown when session leaks are detected.
 *
 * @private
 */
export declare class SessionLeakError extends Error {
    messages: string[];
    constructor(leaks: string[]);
}
/**
 * Error to be thrown when the session pool is exhausted.
 */
export declare class SessionPoolExhaustedError extends Error {
    messages: string[];
    constructor(leaks: string[]);
}
/**
 * Checks whether the given error is a 'Session not found' error.
 * @param error the error to check
 * @return true if the error is a 'Session not found' error, and otherwise false.
 */
export declare function isSessionNotFoundError(error: grpc.ServiceError | undefined): boolean;
/**
 * Checks whether the given error is a 'Database not found' error.
 * @param {Error} error The error to check.
 * @return {boolean} True if the error is a 'Database not found' error, and otherwise false.
 */
export declare function isDatabaseNotFoundError(error: grpc.ServiceError | undefined): boolean;
/**
 * Checks whether the given error is an 'Instance not found' error.
 * @param {Error} error The error to check.
 * @return {boolean} True if the error is an 'Instance not found' error, and otherwise false.
 */
export declare function isInstanceNotFoundError(error: grpc.ServiceError | undefined): boolean;
/**
 * Checks whether the given error is a 'Create session permission' error.
 * @param {Error} error The error to check.
 * @return {boolean} True if the error is a 'Create session permission' error, and otherwise false.
 */
export declare function isCreateSessionPermissionError(error: grpc.ServiceError | undefined): boolean;
/**
 * Checks whether the given error is a 'Could not load the default credentials' error.
 * @param {Error} error The error to check.
 * @return {boolean} True if the error is a 'Could not load the default credentials' error, and otherwise false.
 */
export declare function isDefaultCredentialsNotSetError(error: grpc.ServiceError | undefined): boolean;
/**
 * Checks whether the given error is an 'Unable to detect a Project Id in the current environment' error.
 * @param {Error} error The error to check.
 * @return {boolean} True if the error is an 'Unable to detect a Project Id in the current environment' error, and otherwise false.
 */
export declare function isProjectIdNotSetInEnvironmentError(error: grpc.ServiceError | undefined): boolean;
interface SessionInventory {
    [types.ReadOnly]: Session[];
    [types.ReadWrite]: Session[];
    borrowed: Set<Session>;
}
interface Waiters {
    [types.ReadOnly]: number;
    [types.ReadWrite]: number;
}
export interface CreateSessionsOptions {
    writes?: number;
    reads?: number;
}
/**
 * Class used to manage connections to Spanner.
 *
 * **You don't need to use this class directly, connections will be handled for
 * you.**
 *
 * @class
 * @extends {EventEmitter}
 */
export declare class SessionPool extends EventEmitter implements SessionPoolInterface {
    database: Database;
    isOpen: boolean;
    options: SessionPoolOptions;
    _acquires: PQueue;
    _evictHandle: NodeJS.Timer;
    _inventory: SessionInventory;
    _onClose: Promise<void>;
    _pending: number;
    _pendingPrepare: number;
    _waiters: Waiters;
    _numInProcessPrepare: number;
    _pingHandle: NodeJS.Timer;
    _requests: PQueue;
    _traces: Map<string, trace.StackFrame[]>;
    /**
     * Formats stack trace objects into Node-like stack trace.
     *
     * @param {object[]} trace The trace object.
     * @return {string}
     */
    static formatTrace(frames: trace.StackFrame[]): string;
    /**
     * Total number of available sessions.
     * @type {number}
     */
    get available(): number;
    /**
     * Current fraction of write-prepared sessions in the pool.
     * @type {number}
     */
    get currentWriteFraction(): number;
    /**
     * Total number of borrowed sessions.
     * @type {number}
     */
    get borrowed(): number;
    /**
     * Flag to determine if Pool is full.
     * @type {boolean}
     */
    get isFull(): boolean;
    /**
     * Total number of read sessions.
     * @type {number}
     */
    get reads(): number;
    /**
     * Total size of pool.
     * @type {number}
     */
    get size(): number;
    /**
     * Total number of write sessions.
     * @type {number}
     */
    get writes(): number;
    /**
     * Number of sessions currently being prepared for a read/write transaction
     * before being released into the pool. This number does not include the
     * number of sessions being prepared for a read/write transaction that have
     * already been checked out of the pool.
     * @type {number}
     */
    get pendingPrepare(): number;
    /**
     * Number of sessions being created or prepared for a read/write transaction.
     * @type {number}
     */
    get totalPending(): number;
    /**
     * Current number of waiters for a read-only session.
     * @type {number}
     */
    get numReadWaiters(): number;
    /**
     * Current number of waiters for a read/write session.
     * @type {number}
     */
    get numWriteWaiters(): number;
    /**
     * Sum of read and write waiters.
     * @type {number}
     */
    get totalWaiters(): number;
    /**
     * @constructor
     * @param {Database} database The DB instance.
     * @param {SessionPoolOptions} [options] Configuration options.
     */
    constructor(database: Database, options?: SessionPoolOptions);
    /**
     * Closes and the pool.
     *
     * @emits SessionPool#close
     * @param {SessionPoolCloseCallback} callback The callback function.
     */
    close(callback: SessionPoolCloseCallback): void;
    /**
     * Retrieve a read session.
     *
     * @param {GetReadSessionCallback} callback The callback function.
     */
    getReadSession(callback: GetReadSessionCallback): void;
    /**
     * Retrieve a read/write session.
     *
     * @param {GetWriteSessionCallback} callback The callback function.
     */
    getWriteSession(callback: GetWriteSessionCallback): void;
    /**
     * Opens the pool, filling it to the configured number of read and write
     * sessions.
     *
     * @emits SessionPool#open
     * @return {Promise}
     */
    open(): void;
    /**
     * Releases session back into the pool. If the session is a write session it
     * will also prepare a new transaction before releasing it.
     *
     * @throws {Error} For unknown sessions.
     * @emits SessionPool#available
     * @emits SessionPool#error
     * @emits SessionPool#readonly-available
     * @emits SessionPool#readwrite-available
     * @param {Session} session The session to release.
     */
    release(session: Session): void;
    /**
     * Attempts to borrow a session from the pool.
     *
     * @private
     *
     * @param {string} type The desired type to borrow.
     * @returns {Promise<Session>}
     */
    _acquire(type: types): Promise<Session>;
    /**
     * Moves a session into the borrowed group.
     *
     * @private
     *
     * @param {Session} session The session object.
     */
    _borrow(session: Session): void;
    /**
     * Borrows the first session from specific group. This method may only be called if the inventory
     * actually contains a session of the desired type.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @return {Session}
     */
    _borrowFrom(type: types): Session;
    /**
     * Grabs the next available session.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @returns {Promise<Session>}
     */
    _borrowNextAvailableSession(type: types): Session;
    /**
     * Attempts to create a single session of a certain type.
     *
     * @private
     *
     * @param {string} type The desired type to create.
     * @returns {Promise}
     */
    _createSession(type: types): Promise<void>;
    /**
     * Batch creates sessions and prepares any necessary transactions.
     *
     * @private
     *
     * @param {object} [options] Config specifying how many sessions to create.
     * @returns {Promise}
     * @emits SessionPool#createError
     */
    _createSessions({ reads, writes, }: CreateSessionsOptions): Promise<void>;
    /**
     * Attempts to delete a session, optionally creating a new one of the same
     * type if the pool is still open and we're under the configured min value.
     *
     * @private
     *
     * @fires SessoinPool#error
     * @param {Session} session The session to delete.
     * @returns {Promise}
     */
    _destroy(session: Session): Promise<void>;
    /**
     * Deletes idle sessions that exceed the maxIdle configuration.
     *
     * @private
     */
    _evictIdleSessions(): void;
    /**
     * Fills the pool with the minimum number of sessions.
     *
     * @return {Promise}
     */
    _fill(): Promise<void>;
    /**
     * Retrieves a list of all the idle sessions.
     *
     * @private
     *
     * @returns {Session[]}
     */
    _getIdleSessions(): Session[];
    /**
     * Returns stack traces for sessions that have not been released.
     *
     * @return {string[]}
     */
    _getLeaks(): string[];
    /**
     * Returns true if the pool has a session that is usable for the specified
     * type, i.e. if a read-only session is requested, it returns true if the
     * pool has a read-only or a read/write session. If a read/write session is
     * requested, the method only returns true if the pool has a read/write
     * session available.
     * @param type The type of session.
     * @private
     */
    _hasSessionUsableFor(type: types): boolean;
    /**
     * Attempts to get a session of a specific type. If the type is unavailable it
     * may try to use a different type.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @param {number} startTime Timestamp to use when determining timeouts.
     * @returns {Promise<Session>}
     */
    _getSession(type: types, startTime: number): Promise<Session>;
    /**
     * Checks to see whether or not session is expired.
     *
     * @param {Session} session The session to check.
     * @returns {boolean}
     */
    _isValidSession(session: Session): boolean;
    /**
     * Pings an individual session.
     *
     * @private
     *
     * @param {Session} session The session to ping.
     * @returns {Promise}
     */
    _ping(session: Session): Promise<void>;
    /**
     * Makes a keep alive request to all the idle sessions.
     *
     * @private
     *
     * @returns {Promise}
     */
    _pingIdleSessions(): Promise<void>;
    /**
     * Creates a transaction for a session.
     *
     * @private
     *
     * @param {Session} session The session object.
     * @param {object} options The transaction options.
     * @returns {Promise}
     */
    _prepareTransaction(session: Session): Promise<void>;
    /**
     * Releases a session back into the pool.
     *
     * @private
     *
     * @fires SessionPool#available
     * @fires SessionPool#readonly-available
     * @fires SessionPool#readwrite-available
     * @param {Session} session The session object.
     */
    _release(session: Session): void;
    /**
     * Starts housekeeping (pinging/evicting) of idle sessions.
     *
     * @private
     */
    _startHouseKeeping(): void;
    /**
     * Stops housekeeping.
     *
     * @private
     */
    _stopHouseKeeping(): void;
}
export {};

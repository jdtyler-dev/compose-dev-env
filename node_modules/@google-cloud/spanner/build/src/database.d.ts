/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { ExistsCallback, GetConfig } from '@google-cloud/common';
declare const common: any;
import * as r from 'teeny-request';
import { CallOptions, Operation as GaxOperation } from 'google-gax';
import { BatchTransaction, TransactionIdentifier } from './batch-transaction';
import { google as databaseAdmin, google, google as spannerClient } from '../protos/protos';
import { GetDatabaseOperationsOptions, GetDatabaseOperationsResponse, Instance, GetDatabaseOperationsCallback } from './instance';
import { PartialResultStream } from './partial-result-stream';
import { Session } from './session';
import { SessionPoolCloseCallback, SessionPoolInterface, SessionPoolOptions } from './session-pool';
import { CreateTableCallback, CreateTableResponse, Table } from './table';
import { ExecuteSqlRequest, RunCallback, RunResponse, RunUpdateCallback, Snapshot, TimestampBounds, Transaction } from './transaction';
import { AsyncRunTransactionCallback, RunTransactionCallback, RunTransactionOptions } from './transaction-runner';
import { IOperation, LongRunningCallback, NormalCallback, PagedOptionsWithFilter, PagedResponse, RequestCallback, ResourceCallback, Schema } from './common';
import { Duplex, Readable } from 'stream';
import { EnumKey, RequestConfig, TranslateEnumKeys } from '.';
declare type CreateBatchTransactionCallback = ResourceCallback<BatchTransaction, google.spanner.v1.ITransaction | google.spanner.v1.ISession>;
declare type CreateBatchTransactionResponse = [BatchTransaction, google.spanner.v1.ITransaction | google.spanner.v1.ISession];
declare type DatabaseResponse = [Database, r.Response];
declare type DatabaseCallback = ResourceCallback<Database, r.Response>;
declare type GetSnapshotCallback = NormalCallback<Snapshot>;
declare type GetTransactionCallback = NormalCallback<Transaction>;
export interface SessionPoolConstructor {
    new (database: Database, options?: SessionPoolOptions | null): SessionPoolInterface;
}
export declare type UpdateSchemaCallback = ResourceCallback<GaxOperation, databaseAdmin.longrunning.IOperation>;
export declare type UpdateSchemaResponse = [GaxOperation, databaseAdmin.longrunning.IOperation];
declare type PoolRequestCallback = RequestCallback<Session>;
export declare type GetSessionsOptions = PagedOptionsWithFilter;
/**
 * IDatabase structure with database state enum translated to string form.
 */
declare type IDatabaseTranslatedEnum = Omit<TranslateEnumKeys<databaseAdmin.spanner.admin.database.v1.IDatabase, 'state', typeof databaseAdmin.spanner.admin.database.v1.Database.State>, 'restoreInfo'> & {
    restoreInfo?: IRestoreInfoTranslatedEnum | null;
};
/**
 * IRestoreInfo structure with restore source type enum translated to string form.
 */
declare type IRestoreInfoTranslatedEnum = TranslateEnumKeys<databaseAdmin.spanner.admin.database.v1.IRestoreInfo, 'sourceType', typeof databaseAdmin.spanner.admin.database.v1.RestoreSourceType>;
declare type GetDatabaseMetadataResponse = [IDatabaseTranslatedEnum];
declare type GetDatabaseMetadataCallback = RequestCallback<IDatabaseTranslatedEnum>;
declare type GetSchemaCallback = RequestCallback<string, databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse>;
declare type GetSchemaResponse = [string[], databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse];
declare type GetSessionsCallback = RequestCallback<Session, google.spanner.v1.IListSessionsResponse>;
declare type GetSessionsResponse = PagedResponse<Session, google.spanner.v1.IListSessionsResponse>;
export declare type GetDatabaseConfig = GetConfig & databaseAdmin.spanner.admin.database.v1.IGetDatabaseRequest & {
    gaxOptions?: CallOptions;
};
declare type DatabaseCloseResponse = [google.protobuf.IEmpty];
export declare type CreateSessionResponse = [Session, spannerClient.spanner.v1.ISession];
export interface CreateSessionOptions {
    labels?: {
        [k: string]: string;
    } | null;
    gaxOptions?: CallOptions;
}
export declare type CreateSessionCallback = ResourceCallback<Session, spannerClient.spanner.v1.ISession>;
export interface BatchCreateSessionsOptions extends CreateSessionOptions {
    count: number;
}
export declare type BatchCreateSessionsResponse = [Session[], spannerClient.spanner.v1.IBatchCreateSessionsResponse];
export declare type BatchCreateSessionsCallback = ResourceCallback<Session[], spannerClient.spanner.v1.IBatchCreateSessionsResponse>;
export declare type DatabaseDeleteResponse = [databaseAdmin.protobuf.IEmpty];
export declare type DatabaseDeleteCallback = NormalCallback<databaseAdmin.protobuf.IEmpty>;
export interface CancelableDuplex extends Duplex {
    cancel(): void;
}
export declare type RestoreDatabaseCallback = LongRunningCallback<Database>;
export declare type RestoreDatabaseResponse = [Database, GaxOperation, databaseAdmin.longrunning.IOperation];
export declare type GetRestoreInfoCallback = NormalCallback<IRestoreInfoTranslatedEnum>;
export declare type GetStateCallback = NormalCallback<EnumKey<typeof databaseAdmin.spanner.admin.database.v1.Database.State>>;
interface DatabaseRequest {
    (config: RequestConfig, callback: ResourceCallback<GaxOperation, IOperation>): void;
    <T>(config: RequestConfig, callback: RequestCallback<T>): void;
    <T, R>(config: RequestConfig, callback: RequestCallback<T, R>): void;
}
export interface RestoreOptions {
    encryptionConfig?: databaseAdmin.spanner.admin.database.v1.IRestoreDatabaseEncryptionConfig;
    gaxOptions?: CallOptions;
}
/**
 * Create a Database object to interact with a Cloud Spanner database.
 *
 * @class
 *
 * @param {string} name Name of the database.
 * @param {SessionPoolOptions|SessionPoolInterface} options Session pool
 *     configuration options or custom pool interface.
 * @param {google.spanner.v1.ExecuteSqlRequest.IQueryOptions} queryOptions
 *     The default query options to use for queries on the database.
 *
 * @example
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const database = instance.database('my-database');
 */
declare class Database extends common.GrpcServiceObject {
    private instance;
    formattedName_: string;
    pool_: SessionPoolInterface;
    queryOptions_?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    resourceHeader_: {
        [k: string]: string;
    };
    request: DatabaseRequest;
    constructor(instance: Instance, name: string, poolOptions?: SessionPoolConstructor | SessionPoolOptions, queryOptions?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions);
    static getEnvironmentQueryOptions(): databaseAdmin.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    batchCreateSessions(options: number | BatchCreateSessionsOptions): Promise<BatchCreateSessionsResponse>;
    batchCreateSessions(options: number | BatchCreateSessionsOptions, callback: BatchCreateSessionsCallback): void;
    /**
     * Get a reference to a {@link BatchTransaction} object.
     *
     * @see {@link BatchTransaction#identifier} to generate an identifier.
     *
     * @param {TransactionIdentifier} identifier The transaction identifier.
     * @param {object} [options] [Transaction options](https://cloud.google.com/spanner/docs/timestamp-bounds).
     * @returns {BatchTransaction} A batch transaction object.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const transaction = database.batchTransaction({
     *   session: 'my-session',
     *   transaction: 'my-transaction',
     *   readTimestamp: 1518464696657
     * });
     */
    batchTransaction(identifier: TransactionIdentifier, options?: TimestampBounds): BatchTransaction;
    close(callback: SessionPoolCloseCallback): void;
    close(): Promise<DatabaseCloseResponse>;
    createBatchTransaction(options?: TimestampBounds): Promise<CreateBatchTransactionResponse>;
    createBatchTransaction(callback: CreateBatchTransactionCallback): void;
    createBatchTransaction(options: TimestampBounds, callback: CreateBatchTransactionCallback): void;
    createSession(options: CreateSessionOptions): Promise<CreateSessionResponse>;
    createSession(callback: CreateSessionCallback): void;
    createSession(options: CreateSessionOptions, callback: CreateSessionCallback): void;
    createTable(schema: Schema, gaxOptions?: CallOptions): Promise<CreateTableResponse>;
    createTable(schema: Schema, callback: CreateTableCallback): void;
    createTable(schema: Schema, gaxOptions: CallOptions, callback: CreateTableCallback): void;
    /**
     * Decorates transaction so that when end() is called it will return the session
     * back into the pool.
     *
     * @private
     *
     * @param {Session} session The session to release.
     * @param {Transaction} transaction The transaction to observe.
     * @returns {Transaction}
     */
    private _releaseOnEnd;
    delete(gaxOptions?: CallOptions): Promise<DatabaseDeleteResponse>;
    delete(callback: DatabaseDeleteCallback): void;
    delete(gaxOptions: CallOptions, callback: DatabaseDeleteCallback): void;
    exists(gaxOptions?: CallOptions): Promise<[boolean]>;
    exists(callback: ExistsCallback): void;
    exists(gaxOptions: CallOptions, callback: ExistsCallback): void;
    get(options?: GetDatabaseConfig): Promise<DatabaseResponse>;
    get(callback: DatabaseCallback): void;
    get(options: GetDatabaseConfig, callback: DatabaseCallback): void;
    getMetadata(gaxOptions?: CallOptions): Promise<GetDatabaseMetadataResponse>;
    getMetadata(callback: GetDatabaseMetadataCallback): void;
    getMetadata(gaxOptions: CallOptions, callback: GetDatabaseMetadataCallback): void;
    getRestoreInfo(options?: CallOptions): Promise<IRestoreInfoTranslatedEnum | undefined>;
    getRestoreInfo(callback: GetRestoreInfoCallback): void;
    getRestoreInfo(options: CallOptions, callback: GetRestoreInfoCallback): void;
    getState(options?: CallOptions): Promise<EnumKey<typeof databaseAdmin.spanner.admin.database.v1.Database.State> | undefined>;
    getState(callback: GetStateCallback): void;
    getState(options: CallOptions, callback: GetStateCallback): void;
    getSchema(options?: CallOptions): Promise<GetSchemaResponse>;
    getSchema(callback: GetSchemaCallback): void;
    getSchema(options: CallOptions, callback: GetSchemaCallback): void;
    getSessions(options?: GetSessionsOptions): Promise<GetSessionsResponse>;
    getSessions(callback: GetSessionsCallback): void;
    getSessions(options: GetSessionsOptions, callback: GetSessionsCallback): void;
    /**
     * Get a list of sessions as a readable object stream.
     *
     * Wrapper around {@link v1.SpannerClient#listSessions}
     *
     * @see {@link v1.SpannerClient#listSessions}
     * @see [ListSessions API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ListSessions)
     *
     * @method Spanner#getSessionsStream
     * @param {GetSessionsOptions} [options] Options object for listing sessions.
     * @returns {ReadableStream} A readable stream that emits {@link Session}
     *     instances.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSessionsStream()
     *   .on('error', console.error)
     *   .on('data', function(database) {
     *     // `sessions` is a `Session` object.
     *   })
     *   .on('end', function() {
     *     // All sessions retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.getSessionsStream()
     *   .on('data', function(session) {
     *     this.end();
     *   });
     */
    getSessionsStream(options?: GetSessionsOptions): NodeJS.ReadableStream;
    getSnapshot(options?: TimestampBounds): Promise<[Snapshot]>;
    getSnapshot(callback: GetSnapshotCallback): void;
    getSnapshot(options: TimestampBounds, callback: GetSnapshotCallback): void;
    getTransaction(): Promise<[Transaction]>;
    getTransaction(callback: GetTransactionCallback): void;
    getOperations(options?: GetDatabaseOperationsOptions): Promise<GetDatabaseOperationsResponse>;
    getOperations(callback: GetDatabaseOperationsCallback): void;
    getOperations(options: GetDatabaseOperationsOptions, callback: GetDatabaseOperationsCallback): void;
    makePooledRequest_(config: RequestConfig): Promise<Session>;
    makePooledRequest_(config: RequestConfig, callback: PoolRequestCallback): void;
    /**
     * Make an API request as a stream, first assuring an active session is used.
     *
     * @private
     *
     * @param {object} config Request config
     * @returns {Stream}
     */
    makePooledStreamingRequest_(config: RequestConfig): Readable;
    restore(backupPath: string): Promise<RestoreDatabaseResponse>;
    restore(backupPath: string, options?: RestoreOptions | CallOptions): Promise<RestoreDatabaseResponse>;
    restore(backupPath: string, callback: RestoreDatabaseCallback): void;
    restore(backupPath: string, options: RestoreOptions | CallOptions, callback: RestoreDatabaseCallback): void;
    run(query: string | ExecuteSqlRequest): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, options?: TimestampBounds): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, callback: RunCallback): void;
    run(query: string | ExecuteSqlRequest, options: TimestampBounds, callback: RunCallback): void;
    runPartitionedUpdate(query: string | ExecuteSqlRequest): Promise<[number]>;
    runPartitionedUpdate(query: string | ExecuteSqlRequest, callback?: RunUpdateCallback): void;
    _runPartitionedUpdate(session: Session, query: string | ExecuteSqlRequest, callback?: RunUpdateCallback): void | Promise<number>;
    /**
     * Create a readable object stream to receive resulting rows from a SQL
     * statement.
     *
     * Wrapper around {@link v1.SpannerClient#executeStreamingSql}.
     *
     * @see {@link v1.SpannerClient#executeStreamingSql}
     * @see [Query Syntax](https://cloud.google.com/spanner/docs/query-syntax)
     * @see [ExecuteSql API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteSql)
     *
     * @fires PartialResultStream#response
     *
     * @param {string|ExecuteSqlRequest} query A SQL query or
     *     {@link ExecuteSqlRequest} object.
     * @param {TimestampBounds} [options] Snapshot timestamp bounds.
     * @returns {PartialResultStream} A readable stream that emits rows.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const query = 'SELECT * FROM Singers';
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = [
     *     //   {
     *     //     name: 'SingerId',
     *     //     value: '1'
     *     //   },
     *     //   {
     *     //     name: 'Name',
     *     //     value: 'Eddie Wilson'
     *     //   }
     *     // ]
     *   // ]
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Rows are returned as an array of objects. Each object has a `name` and
     * // `value` property. To get a serialized object, call `toJSON()`.
     * //-
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row.toJSON() = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Alternatively, set `query.json` to `true`, and this step will be performed
     * // automatically.
     * //-
     * query.json = true;
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // The SQL query string can contain parameter placeholders. A parameter
     * // placeholder consists of '@' followed by the parameter name.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you need to enforce a specific param type, a types map can be provided.
     * // This is typically useful if your param value can be null.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   },
     *   types: {
     *     name: 'string'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.runStream(query)
     *   .on('data', function(row) {
     *     this.end();
     *   });
     */
    runStream(query: string | ExecuteSqlRequest, options?: TimestampBounds): PartialResultStream;
    runTransaction(runFn: RunTransactionCallback): void;
    runTransaction(options: RunTransactionOptions, runFn: RunTransactionCallback): void;
    runTransactionAsync<T = {}>(runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    runTransactionAsync<T = {}>(options: RunTransactionOptions, runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    /**
     * Create a Session object.
     *
     * It is unlikely you will need to interact with sessions directly. By default,
     * sessions are created and utilized for maximum performance automatically.
     *
     * @param {string} [name] The name of the session. If not provided, it is
     *     assumed you are going to create it.
     * @returns {Session} A Session object.
     *
     * @example
     * var session = database.session('session-name');
     */
    session(name?: string): Session;
    /**
     * Get a reference to a Table object.
     *
     * @throws {Error} If a name is not provided.
     *
     * @param {string} name The name of the table.
     * @return {Table} A Table object.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const table = database.table('Singers');
     */
    table(name: string): Table;
    updateSchema(statements: Schema, gaxOptions?: CallOptions): Promise<UpdateSchemaResponse>;
    updateSchema(statements: Schema, callback: UpdateSchemaCallback): void;
    updateSchema(statements: Schema, gaxOptions: CallOptions, callback: UpdateSchemaCallback): void;
    /**
     * Format the database name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * Database.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-database'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/databases/my-database'
     */
    static formatName_(instanceName: string, name: string): string;
}
/**
 * Reference to the {@link Database} class.
 * @name module:@google-cloud/spanner.Database
 * @see Database
 */
export { Database };
